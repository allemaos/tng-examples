// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R4A
// for tango (tango@tango-VirtualBox) on Fri Jul 20 16:40:36 2018

// Copyright (c) 2000-2018 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "SSHCLIENTasp_echo.hh"

namespace SSHCLIENTasp__echo {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean set_module_param(Module_Param& param);
static void log_module_param();
static boolean init_comp_type(const char *component_type, boolean init_base_comps);
static boolean init_system_port(const char* component_type, const char* port_name);
static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments);
static void module_control_part();

/* Literal string constants */

static const CHARSTRING cs_3(0, NULL),
cs_4(8, "** msg: "),
cs_1(2, "-C"),
cs_0(2, "22"),
cs_8(10, "Password: "),
cs_9(2, "cd"),
cs_11(18, "exit; exit; logout"),
cs_10(2, "ls"),
cs_7(12, "nodeIPAddr: "),
cs_6(5, "pwd: "),
cs_2(13, "regex_prompt1"),
cs_5(9, "usrname: ");
static const unsigned char module_checksum[] = { 0x91, 0xb0, 0x35, 0x83, 0x91, 0x9b, 0x07, 0xe7, 0x90, 0xb4, 0xbf, 0xb9, 0xd9, 0xf4, 0x4c, 0xcd };

/* Class definitions for internal use */

class as__status_Default : public Default_Base {
public:
as__status_Default();
alt_status call_altstep();
};

class as__prompt_Default : public Default_Base {
public:
as__prompt_Default();
alt_status call_altstep();
};

class as__conversation__error_Default : public Default_Base {
public:
as__conversation__error_Default();
alt_status call_altstep();
};

class as__T__SSHresp__timeout_Default : public Default_Base {
public:
as__T__SSHresp__timeout_Default();
alt_status call_altstep();
};

class as__regular__msg__rec_Default : public Default_Base {
public:
as__regular__msg__rec_Default();
alt_status call_altstep();
};


/* Global variable definitions */

static CHARSTRING modulepar_usrname;
const CHARSTRING& usrname = modulepar_usrname;
static CHARSTRING modulepar_pwd;
const CHARSTRING& pwd = modulepar_pwd;
static CHARSTRING modulepar_nodeIPAddr;
const CHARSTRING& nodeIPAddr = modulepar_nodeIPAddr;
static SSHCLIENTasp__Types::ASP__SSH__SetUserID_template template_t__userId;
const SSHCLIENTasp__Types::ASP__SSH__SetUserID_template& t__userId = template_t__userId;
static SSHCLIENTasp__Types::ASP__SSH__Close_template template_t__close;
const SSHCLIENTasp__Types::ASP__SSH__Close_template& t__close = template_t__close;
static SSHCLIENTasp__Types::ASP__SSH__Connect_template template_t__connect;
const SSHCLIENTasp__Types::ASP__SSH__Connect_template& t__connect = template_t__connect;
static SSHCLIENTasp__Types::ASP__SSH__Status_template template_t__status;
const SSHCLIENTasp__Types::ASP__SSH__Status_template& t__status = template_t__status;
static SSHCLIENTasp__Types::ASP__SSH__Status_template template_t__status__ok;
const SSHCLIENTasp__Types::ASP__SSH__Status_template& t__status__ok = template_t__status__ok;
static SSHCLIENTasp__Types::ASP__SSH__PseudoPrompt_template template_t__pseudoPrompt;
const SSHCLIENTasp__Types::ASP__SSH__PseudoPrompt_template& t__pseudoPrompt = template_t__pseudoPrompt;
static SSHCLIENTasp__Types::ASP__SSH__SetRemotePort_template template_t__remotePort;
const SSHCLIENTasp__Types::ASP__SSH__SetRemotePort_template& t__remotePort = template_t__remotePort;
static SSHCLIENTasp__Types::ASP__SSH__SetAdditionalParameters_template template_t__parameters;
const SSHCLIENTasp__Types::ASP__SSH__SetAdditionalParameters_template& t__parameters = template_t__parameters;
static CHARSTRING_template template_t__ASP__SSH;
const CHARSTRING_template& t__ASP__SSH = template_t__ASP__SSH;
const TTCN_Typedescriptor_t& SSH__CT_descr_ = COMPONENT_descr_;
SSHCLIENTasp__PortType::SSHCLIENTasp__PT SSH__CT_component_SSH__PCO("SSH_PCO");
TIMER SSH__CT_component_T__sshResp("T_sshResp");
CHARSTRING SSH__CT_component_sshRespStr;
TTCN_Module module_object("SSHCLIENTasp_echo", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, set_module_param, NULL, log_module_param, init_comp_type, init_system_port, start_ptc_function, module_control_part);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

as__status_Default::as__status_Default()
 : Default_Base("as_status")
{
}

alt_status as__status_Default::call_altstep()
{
return as__status_instance();
}

as__prompt_Default::as__prompt_Default()
 : Default_Base("as_prompt")
{
}

alt_status as__prompt_Default::call_altstep()
{
return as__prompt_instance();
}

as__conversation__error_Default::as__conversation__error_Default()
 : Default_Base("as_conversation_error")
{
}

alt_status as__conversation__error_Default::call_altstep()
{
return as__conversation__error_instance();
}

as__T__SSHresp__timeout_Default::as__T__SSHresp__timeout_Default()
 : Default_Base("as_T_SSHresp_timeout")
{
}

alt_status as__T__SSHresp__timeout_Default::call_altstep()
{
return as__T__SSHresp__timeout_instance();
}

as__regular__msg__rec_Default::as__regular__msg__rec_Default()
 : Default_Base("as_regular_msg_rec")
{
}

alt_status as__regular__msg__rec_Default::call_altstep()
{
return as__regular__msg__rec_instance();
}


/* Bodies of functions, altsteps and testcases */

SSHCLIENTasp__Types::ASP__SSH__SetRegexPrompt_template t__regexPrompt(const CHARSTRING& rp)
{
SSHCLIENTasp__Types::ASP__SSH__SetRegexPrompt_template ret_val;
ret_val.prompt__name() = cs_2;
ret_val.prompt__value() = rp;
return ret_val;
}

CHARSTRING_template t__Pattern(const CHARSTRING& vl__pattern)
{
CHARSTRING_template ret_val;
ret_val = CHARSTRING_template(STRING_PATTERN, (CHARSTRING)vl__pattern, FALSE);
return ret_val;
}

alt_status as__status_instance()
{
alt_status ret_val = ALT_NO;
/* SSHCLIENTasp_echo.ttcn, line 53 */
switch (SSH__CT_component_SSH__PCO.receive(t__status__ok, NULL, any_compref, NULL, NULL)) {
case ALT_YES:
{
/* SSHCLIENTasp_echo.ttcn, line 54 */
SSH__CT_component_T__sshResp.stop();
/* SSHCLIENTasp_echo.ttcn, line 55 */
TTCN_Logger::log_str(TTCN_USER, "as_status: OK received");
/* SSHCLIENTasp_echo.ttcn, line 56 */
SSH__CT_component_T__sshResp.start(3.0);
/* SSHCLIENTasp_echo.ttcn, line 57 */
return ALT_REPEAT;
}
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
/* SSHCLIENTasp_echo.ttcn, line 59 */
switch (SSH__CT_component_SSH__PCO.receive(t__status, NULL, any_compref, NULL, NULL)) {
case ALT_YES:
{
/* SSHCLIENTasp_echo.ttcn, line 60 */
TTCN_Logger::log_str(TTCN_USER, "as_status: Status received");
/* SSHCLIENTasp_echo.ttcn, line 61 */
SSH__CT_component_T__sshResp.stop();
}
return ALT_YES;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
return ret_val;
}

void as__status()
{
altstep_begin:
boolean block_flag = FALSE;
alt_status altstep_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
for ( ; ; ) {
TTCN_Snapshot::take_new(block_flag);
if (altstep_flag != ALT_NO) {
altstep_flag = as__status_instance();
if (altstep_flag == ALT_YES || altstep_flag == ALT_BREAK) return;
else if (altstep_flag == ALT_REPEAT) goto altstep_begin;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) return;
else if (default_flag == ALT_REPEAT) goto altstep_begin;
}
if (altstep_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in altstep as_status.");
else block_flag = TRUE;
}
}

Default_Base *activate_as__status()
{
return new as__status_Default();
}

alt_status as__prompt_instance()
{
alt_status ret_val = ALT_NO;
/* SSHCLIENTasp_echo.ttcn, line 66 */
switch (SSH__CT_component_SSH__PCO.receive(t__pseudoPrompt, NULL, any_compref, NULL, NULL)) {
case ALT_YES:
{
/* SSHCLIENTasp_echo.ttcn, line 67 */
TTCN_Logger::log_str(TTCN_USER, "as_prompt: PseudoPrompt received");
/* SSHCLIENTasp_echo.ttcn, line 68 */
SSH__CT_component_T__sshResp.stop();
}
return ALT_YES;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
return ret_val;
}

void as__prompt()
{
altstep_begin:
boolean block_flag = FALSE;
alt_status altstep_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
for ( ; ; ) {
TTCN_Snapshot::take_new(block_flag);
if (altstep_flag != ALT_NO) {
altstep_flag = as__prompt_instance();
if (altstep_flag == ALT_YES || altstep_flag == ALT_BREAK) return;
else if (altstep_flag == ALT_REPEAT) goto altstep_begin;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) return;
else if (default_flag == ALT_REPEAT) goto altstep_begin;
}
if (altstep_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in altstep as_prompt.");
else block_flag = TRUE;
}
}

Default_Base *activate_as__prompt()
{
return new as__prompt_Default();
}

alt_status as__conversation__error_instance()
{
alt_status ret_val = ALT_NO;
/* SSHCLIENTasp_echo.ttcn, line 73 */
switch (SSH__CT_component_SSH__PCO.receive(t__close, NULL, any_compref, NULL, NULL)) {
case ALT_YES:
{
/* SSHCLIENTasp_echo.ttcn, line 74 */
TTCN_Logger::log_str(TTCN_USER, "as_conversation_error: ASP_SSH_Close received");
/* SSHCLIENTasp_echo.ttcn, line 75 */
SSH__CT_component_T__sshResp.stop();
}
return ALT_YES;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
return ret_val;
}

void as__conversation__error()
{
altstep_begin:
boolean block_flag = FALSE;
alt_status altstep_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
for ( ; ; ) {
TTCN_Snapshot::take_new(block_flag);
if (altstep_flag != ALT_NO) {
altstep_flag = as__conversation__error_instance();
if (altstep_flag == ALT_YES || altstep_flag == ALT_BREAK) return;
else if (altstep_flag == ALT_REPEAT) goto altstep_begin;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) return;
else if (default_flag == ALT_REPEAT) goto altstep_begin;
}
if (altstep_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in altstep as_conversation_error.");
else block_flag = TRUE;
}
}

Default_Base *activate_as__conversation__error()
{
return new as__conversation__error_Default();
}

alt_status as__T__SSHresp__timeout_instance()
{
alt_status ret_val = ALT_NO;
/* SSHCLIENTasp_echo.ttcn, line 80 */
switch (SSH__CT_component_T__sshResp.timeout(NULL)) {
case ALT_YES:
{
/* SSHCLIENTasp_echo.ttcn, line 81 */
TTCN_Logger::log_str(TTCN_USER, "as_T_SSHresp_timeout: command response timeout");
}
return ALT_YES;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
return ret_val;
}

void as__T__SSHresp__timeout()
{
altstep_begin:
boolean block_flag = FALSE;
alt_status altstep_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
for ( ; ; ) {
TTCN_Snapshot::take_new(block_flag);
if (altstep_flag != ALT_NO) {
altstep_flag = as__T__SSHresp__timeout_instance();
if (altstep_flag == ALT_YES || altstep_flag == ALT_BREAK) return;
else if (altstep_flag == ALT_REPEAT) goto altstep_begin;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) return;
else if (default_flag == ALT_REPEAT) goto altstep_begin;
}
if (altstep_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in altstep as_T_SSHresp_timeout.");
else block_flag = TRUE;
}
}

Default_Base *activate_as__T__SSHresp__timeout()
{
return new as__T__SSHresp__timeout_Default();
}

alt_status as__regular__msg__rec_instance()
{
/* SSHCLIENTasp_echo.ttcn, line 86 */
CHARSTRING msg;
alt_status ret_val = ALT_NO;
/* SSHCLIENTasp_echo.ttcn, line 87 */
switch (SSH__CT_component_SSH__PCO.receive(t__ASP__SSH, &(msg), any_compref, NULL, NULL)) {
case ALT_YES:
{
/* SSHCLIENTasp_echo.ttcn, line 88 */
SSH__CT_component_T__sshResp.stop();
/* SSHCLIENTasp_echo.ttcn, line 89 */
{
CHARSTRING tmp_0;
tmp_0 = (SSH__CT_component_sshRespStr + msg);
SSH__CT_component_sshRespStr = tmp_0;
}
/* SSHCLIENTasp_echo.ttcn, line 90 */
try {
TTCN_Logger::begin_event(TTCN_USER);
(cs_4 + msg).log();
TTCN_Logger::end_event();
} catch (...) {
TTCN_Logger::finish_event();
throw;
}
/* SSHCLIENTasp_echo.ttcn, line 91 */
SSH__CT_component_T__sshResp.start(3.0);
/* SSHCLIENTasp_echo.ttcn, line 92 */
return ALT_REPEAT;
}
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
/* SSHCLIENTasp_echo.ttcn, line 94 */
switch (as__status_instance()) {
case ALT_YES:
return ALT_YES;
case ALT_REPEAT:
return ALT_REPEAT;
case ALT_BREAK:
return ALT_BREAK;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
/* SSHCLIENTasp_echo.ttcn, line 95 */
switch (as__prompt_instance()) {
case ALT_YES:
return ALT_YES;
case ALT_REPEAT:
return ALT_REPEAT;
case ALT_BREAK:
return ALT_BREAK;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
/* SSHCLIENTasp_echo.ttcn, line 96 */
switch (as__conversation__error_instance()) {
case ALT_YES:
return ALT_YES;
case ALT_REPEAT:
return ALT_REPEAT;
case ALT_BREAK:
return ALT_BREAK;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
/* SSHCLIENTasp_echo.ttcn, line 97 */
switch (as__T__SSHresp__timeout_instance()) {
case ALT_YES:
return ALT_YES;
case ALT_REPEAT:
return ALT_REPEAT;
case ALT_BREAK:
return ALT_BREAK;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
return ret_val;
}

void as__regular__msg__rec()
{
altstep_begin:
boolean block_flag = FALSE;
alt_status altstep_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
for ( ; ; ) {
TTCN_Snapshot::take_new(block_flag);
if (altstep_flag != ALT_NO) {
altstep_flag = as__regular__msg__rec_instance();
if (altstep_flag == ALT_YES || altstep_flag == ALT_BREAK) return;
else if (altstep_flag == ALT_REPEAT) goto altstep_begin;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) return;
else if (default_flag == ALT_REPEAT) goto altstep_begin;
}
if (altstep_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in altstep as_regular_msg_rec.");
else block_flag = TRUE;
}
}

Default_Base *activate_as__regular__msg__rec()
{
return new as__regular__msg__rec_Default();
}

verdicttype testcase_tc1(boolean has_timer, double timer_value)
{
TTCN_Runtime::check_begin_testcase(has_timer, timer_value);
try {
TTCN_Runtime::begin_testcase("SSHCLIENTasp_echo", "tc1", "SSHCLIENTasp_echo", "SSH_CT", "SSHCLIENTasp_echo", "SSH_CT", has_timer, timer_value);
/* SSHCLIENTasp_echo.ttcn, line 101 */
CHARSTRING msg;
/* SSHCLIENTasp_echo.ttcn, line 103 */
TTCN_Logger::log_str(TTCN_USER, "tc1 started");
/* SSHCLIENTasp_echo.ttcn, line 104 */
try {
TTCN_Logger::begin_event(TTCN_USER);
(cs_5 + usrname).log();
TTCN_Logger::end_event();
} catch (...) {
TTCN_Logger::finish_event();
throw;
}
/* SSHCLIENTasp_echo.ttcn, line 105 */
try {
TTCN_Logger::begin_event(TTCN_USER);
(cs_6 + pwd).log();
TTCN_Logger::end_event();
} catch (...) {
TTCN_Logger::finish_event();
throw;
}
/* SSHCLIENTasp_echo.ttcn, line 106 */
try {
TTCN_Logger::begin_event(TTCN_USER);
(cs_7 + nodeIPAddr).log();
TTCN_Logger::end_event();
} catch (...) {
TTCN_Logger::finish_event();
throw;
}
/* SSHCLIENTasp_echo.ttcn, line 108 */
TTCN_Runtime::map_port(self, SSH__CT_component_SSH__PCO.get_name(), SYSTEM_COMPREF, SSH__CT_component_SSH__PCO.get_name());
/* SSHCLIENTasp_echo.ttcn, line 109 */
SSH__CT_component_T__sshResp.start(1.0e1);
/* SSHCLIENTasp_echo.ttcn, line 112 */
SSH__CT_component_SSH__PCO.send(t__userId);
/* SSHCLIENTasp_echo.ttcn, line 113 */
SSH__CT_component_SSH__PCO.send(t__remotePort);
/* SSHCLIENTasp_echo.ttcn, line 114 */
SSH__CT_component_SSH__PCO.send(t__parameters);
/* SSHCLIENTasp_echo.ttcn, line 115 */
SSH__CT_component_SSH__PCO.send(t__connect);
/* SSHCLIENTasp_echo.ttcn, line 118 */
{
tmp_1:
alt_status tmp_1_alt_flag_0 = ALT_MAYBE;
alt_status tmp_1_alt_flag_1 = ALT_MAYBE;
alt_status tmp_1_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_1_alt_flag_0 == ALT_MAYBE) {
/* SSHCLIENTasp_echo.ttcn, line 119 */
tmp_1_alt_flag_0 = SSH__CT_component_SSH__PCO.receive(CHARSTRING_template(cs_8), NULL, any_compref, NULL, NULL);
if (tmp_1_alt_flag_0 == ALT_YES) {
/* SSHCLIENTasp_echo.ttcn, line 120 */
SSH__CT_component_T__sshResp.stop();
/* SSHCLIENTasp_echo.ttcn, line 121 */
SSH__CT_component_SSH__PCO.send(pwd);
/* SSHCLIENTasp_echo.ttcn, line 122 */
goto tmp_1;
}
}
if (tmp_1_alt_flag_1 == ALT_MAYBE) {
/* SSHCLIENTasp_echo.ttcn, line 124 */
tmp_1_alt_flag_1 = as__regular__msg__rec_instance();
if (tmp_1_alt_flag_1 == ALT_REPEAT) goto tmp_1;
if (tmp_1_alt_flag_1 == ALT_BREAK) break;
if (tmp_1_alt_flag_1 == ALT_YES) break;
}
if (tmp_1_default_flag == ALT_MAYBE) {
tmp_1_default_flag = TTCN_Default::try_altsteps();
if (tmp_1_default_flag == ALT_YES || tmp_1_default_flag == ALT_BREAK) break;
else if (tmp_1_default_flag == ALT_REPEAT) goto tmp_1;
}
/* SSHCLIENTasp_echo.ttcn, line 118 */
if (tmp_1_alt_flag_0 == ALT_NO && tmp_1_alt_flag_1 == ALT_NO && tmp_1_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file SSHCLIENTasp_echo.ttcn between lines 118 and 125.");
TTCN_Snapshot::take_new(TRUE);
}
}
/* SSHCLIENTasp_echo.ttcn, line 129 */
f__send__command(cs_9, cs_3, PASS);
/* SSHCLIENTasp_echo.ttcn, line 130 */
f__send__command(cs_10, cs_3, FAIL);
/* SSHCLIENTasp_echo.ttcn, line 133 */
SSH__CT_component_SSH__PCO.send(cs_11);
/* SSHCLIENTasp_echo.ttcn, line 134 */
SSH__CT_component_T__sshResp.start(3.0);
/* SSHCLIENTasp_echo.ttcn, line 136 */
{
tmp_2:
alt_status tmp_2_alt_flag_0 = ALT_MAYBE;
alt_status tmp_2_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_2_alt_flag_0 == ALT_MAYBE) {
/* SSHCLIENTasp_echo.ttcn, line 137 */
tmp_2_alt_flag_0 = as__regular__msg__rec_instance();
if (tmp_2_alt_flag_0 == ALT_REPEAT) goto tmp_2;
if (tmp_2_alt_flag_0 == ALT_BREAK) break;
if (tmp_2_alt_flag_0 == ALT_YES) break;
}
if (tmp_2_default_flag == ALT_MAYBE) {
tmp_2_default_flag = TTCN_Default::try_altsteps();
if (tmp_2_default_flag == ALT_YES || tmp_2_default_flag == ALT_BREAK) break;
else if (tmp_2_default_flag == ALT_REPEAT) goto tmp_2;
}
/* SSHCLIENTasp_echo.ttcn, line 136 */
if (tmp_2_alt_flag_0 == ALT_NO && tmp_2_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file SSHCLIENTasp_echo.ttcn between lines 136 and 138.");
TTCN_Snapshot::take_new(TRUE);
}
}
/* SSHCLIENTasp_echo.ttcn, line 140 */
TTCN_Runtime::unmap_port(self, SSH__CT_component_SSH__PCO.get_name(), SYSTEM_COMPREF, SSH__CT_component_SSH__PCO.get_name());
/* SSHCLIENTasp_echo.ttcn, line 141 */
TTCN_Logger::log_str(TTCN_USER, "tc1 finished");
/* SSHCLIENTasp_echo.ttcn, line 143 */
if ((TTCN_Runtime::getverdict() == NONE)) {
/* SSHCLIENTasp_echo.ttcn, line 144 */
TTCN_Logger::log_str(TTCN_USER, "Verdict don't specified. I am so sorry.");
/* SSHCLIENTasp_echo.ttcn, line 145 */
TTCN_Runtime::setverdict(INCONC);
}
} catch (const TC_Error& tc_error) {
} catch (const TC_End& tc_end) {
TTCN_Logger::log_str(TTCN_FUNCTION, "Test case tc1 was stopped.");
}
return TTCN_Runtime::end_testcase();
}

void f__send__command(const CHARSTRING& vl__cmd, const CHARSTRING& vl__pattern, const VERDICTTYPE& vl__verdict)
{
/* SSHCLIENTasp_echo.ttcn, line 152 */
SSH__CT_component_SSH__PCO.send(vl__cmd);
/* SSHCLIENTasp_echo.ttcn, line 153 */
{
tmp_3:
alt_status tmp_3_alt_flag_0 = ALT_MAYBE;
alt_status tmp_3_alt_flag_1 = ALT_MAYBE;
alt_status tmp_3_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_3_alt_flag_0 == ALT_MAYBE) {
/* SSHCLIENTasp_echo.ttcn, line 154 */
tmp_3_alt_flag_0 = SSH__CT_component_SSH__PCO.receive(t__Pattern(vl__pattern), NULL, any_compref, NULL, NULL);
if (tmp_3_alt_flag_0 == ALT_YES) {
/* SSHCLIENTasp_echo.ttcn, line 155 */
SSH__CT_component_T__sshResp.stop();
/* SSHCLIENTasp_echo.ttcn, line 156 */
TTCN_Runtime::setverdict(vl__verdict);
/* SSHCLIENTasp_echo.ttcn, line 157 */
goto tmp_3;
}
}
if (tmp_3_alt_flag_1 == ALT_MAYBE) {
/* SSHCLIENTasp_echo.ttcn, line 159 */
tmp_3_alt_flag_1 = as__regular__msg__rec_instance();
if (tmp_3_alt_flag_1 == ALT_REPEAT) goto tmp_3;
if (tmp_3_alt_flag_1 == ALT_BREAK) break;
if (tmp_3_alt_flag_1 == ALT_YES) break;
}
if (tmp_3_default_flag == ALT_MAYBE) {
tmp_3_default_flag = TTCN_Default::try_altsteps();
if (tmp_3_default_flag == ALT_YES || tmp_3_default_flag == ALT_BREAK) break;
else if (tmp_3_default_flag == ALT_REPEAT) goto tmp_3;
}
/* SSHCLIENTasp_echo.ttcn, line 153 */
if (tmp_3_alt_flag_0 == ALT_NO && tmp_3_alt_flag_1 == ALT_NO && tmp_3_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file SSHCLIENTasp_echo.ttcn between lines 153 and 160.");
TTCN_Snapshot::take_new(TRUE);
}
}
}

void start_f__send__command(const COMPONENT& component_reference, const CHARSTRING& vl__cmd, const CHARSTRING& vl__pattern, const VERDICTTYPE& vl__verdict)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_send_command(");
vl__cmd.log();
TTCN_Logger::log_event_str(", ");
vl__pattern.log();
TTCN_Logger::log_event_str(", ");
vl__verdict.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "SSHCLIENTasp_echo", "f_send_command", text_buf);
vl__cmd.encode_text(text_buf);
vl__pattern.encode_text(text_buf);
vl__verdict.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}


/* Bodies of static functions */

static void pre_init_module()
{
SSHCLIENTasp__PortType::module_object.pre_init_module();
module_object.add_altstep("as_status", (genericfunc_t)&as__status_instance, (genericfunc_t )&activate_as__status, (genericfunc_t )&as__status);
module_object.add_altstep("as_prompt", (genericfunc_t)&as__prompt_instance, (genericfunc_t )&activate_as__prompt, (genericfunc_t )&as__prompt);
module_object.add_altstep("as_conversation_error", (genericfunc_t)&as__conversation__error_instance, (genericfunc_t )&activate_as__conversation__error, (genericfunc_t )&as__conversation__error);
module_object.add_altstep("as_T_SSHresp_timeout", (genericfunc_t)&as__T__SSHresp__timeout_instance, (genericfunc_t )&activate_as__T__SSHresp__timeout, (genericfunc_t )&as__T__SSHresp__timeout);
module_object.add_altstep("as_regular_msg_rec", (genericfunc_t)&as__regular__msg__rec_instance, (genericfunc_t )&activate_as__regular__msg__rec, (genericfunc_t )&as__regular__msg__rec);
module_object.add_testcase_nonpard("tc1", testcase_tc1);
module_object.add_function("f_send_command", (genericfunc_t)&f__send__command, (genericfunc_t)&start_f__send__command);
}

static void post_init_module()
{
SSHCLIENTasp__PortType::module_object.post_init_module();
/* SSHCLIENTasp_echo.ttcn, line 32 */
template_t__userId.usrid() = usrname;
/* SSHCLIENTasp_echo.ttcn, line 33 */
template_t__close = NULL_VALUE;
/* SSHCLIENTasp_echo.ttcn, line 34 */
template_t__connect = NULL_VALUE;
/* SSHCLIENTasp_echo.ttcn, line 35 */
template_t__status = ANY_VALUE;
/* SSHCLIENTasp_echo.ttcn, line 36 */
template_t__status__ok.status__code() = 0;
template_t__status__ok.status__message() = ANY_VALUE;
/* SSHCLIENTasp_echo.ttcn, line 37 */
template_t__pseudoPrompt = NULL_VALUE;
/* SSHCLIENTasp_echo.ttcn, line 38 */
template_t__remotePort.remoteport() = cs_0;
/* SSHCLIENTasp_echo.ttcn, line 39 */
template_t__parameters.additionalparameters() = cs_1;
/* SSHCLIENTasp_echo.ttcn, line 42 */
template_t__ASP__SSH = ANY_VALUE;
}

static boolean set_module_param(Module_Param& param)
{
const char* const par_name = param.get_id()->get_current_name();
if (!strcmp(par_name, "usrname")) {
modulepar_usrname.set_param(param);
return TRUE;
} else if (!strcmp(par_name, "pwd")) {
modulepar_pwd.set_param(param);
return TRUE;
} else if (!strcmp(par_name, "nodeIPAddr")) {
modulepar_nodeIPAddr.set_param(param);
return TRUE;
} else return FALSE;
}

static void log_module_param()
{
TTCN_Logger::log_event_str("usrname := ");
usrname.log();
TTCN_Logger::log_event_str(", pwd := ");
pwd.log();
TTCN_Logger::log_event_str(", nodeIPAddr := ");
nodeIPAddr.log();
}

static boolean init_comp_type(const char *component_type, boolean init_base_comps)
{
(void)init_base_comps;
if (!strcmp(component_type, "SSH_CT")) {
SSH__CT_component_SSH__PCO.activate_port();
SSH__CT_component_sshRespStr = cs_3;
return TRUE;
} else return FALSE;
}

static boolean init_system_port(const char* component_type, const char* port_name)
{
if (!strcmp(component_type, "SSH_CT")) {
if (!strcmp(port_name, "SSH_PCO")) {
SSH__CT_component_SSH__PCO.safe_start();
return TRUE;
}
}
return FALSE;
}

static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments)
{
if (!strcmp(function_name, "f_send_command")) {
CHARSTRING vl__cmd;
CHARSTRING vl__pattern;
VERDICTTYPE vl__verdict;
vl__cmd.decode_text(function_arguments);
vl__pattern.decode_text(function_arguments);
vl__verdict.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_send_command(");
vl__cmd.log();
TTCN_Logger::log_event_str(", ");
vl__pattern.log();
TTCN_Logger::log_event_str(", ");
vl__verdict.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__send__command(vl__cmd, vl__pattern, vl__verdict);
TTCN_Runtime::function_finished("f_send_command");
return TRUE;
} else return FALSE;
}

static void module_control_part()
{
TTCN_Runtime::begin_controlpart("SSHCLIENTasp_echo");
/* SSHCLIENTasp_echo.ttcn, line 166 */
testcase_tc1(FALSE, 0.0);
TTCN_Runtime::end_controlpart();
}


} /* end of namespace */
