// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R4A
// for tango (tango@tango-VirtualBox) on Mon Jul 23 18:40:46 2018

// Copyright (c) 2000-2018 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef SSHCLIENTasp__functions_HH
#define SSHCLIENTasp__functions_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "SSHCLIENTasp_PortType.hh"

#if TTCN3_VERSION != 60400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef SSHCLIENTasp__functions_HH
#endif

namespace SSHCLIENTasp__functions {

/* Forward declarations of classes */

class cliPattern2match;
class cliPattern2match_template;
class cliPatternlist;
class cliPatternlist_template;
class CommandStep;
class CommandStep_template;
class CommandList;
class CommandList_template;
class SSH__CT__list;
class SSH__CT__list_template;

} /* end of namespace */

#ifndef SSHCLIENTasp__functions_HH
#define SSHCLIENTasp__functions_HH

namespace SSHCLIENTasp__functions {

/* Type definitions */

typedef COMPONENT SSH__CT;
typedef COMPONENT_template SSH__CT_template;
typedef COMPONENT MTC__CT;
typedef COMPONENT_template MTC__CT_template;

/* Class definitions */

class cliPattern2match {
  CHARSTRING field_pat;
  BOOLEAN field_res;
public:
  cliPattern2match();
  cliPattern2match(const CHARSTRING& par_pat,
    const BOOLEAN& par_res);
  cliPattern2match(const cliPattern2match& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  cliPattern2match& operator=(const cliPattern2match& other_value);
  boolean operator==(const cliPattern2match& other_value) const;
  inline boolean operator!=(const cliPattern2match& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& pat()
    {return field_pat;}
  inline const CHARSTRING& pat() const
    {return field_pat;}
  inline BOOLEAN& res()
    {return field_res;}
  inline const BOOLEAN& res() const
    {return field_res;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class cliPattern2match_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
cliPattern2match_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const cliPattern2match& other_value);
void copy_template(const cliPattern2match_template& other_value);

public:
cliPattern2match_template();
cliPattern2match_template(template_sel other_value);
cliPattern2match_template(const cliPattern2match& other_value);
cliPattern2match_template(const OPTIONAL<cliPattern2match>& other_value);
cliPattern2match_template(const cliPattern2match_template& other_value);
~cliPattern2match_template();
cliPattern2match_template& operator=(template_sel other_value);
cliPattern2match_template& operator=(const cliPattern2match& other_value);
cliPattern2match_template& operator=(const OPTIONAL<cliPattern2match>& other_value);
cliPattern2match_template& operator=(const cliPattern2match_template& other_value);
boolean match(const cliPattern2match& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
cliPattern2match valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
cliPattern2match_template& list_item(unsigned int list_index) const;
CHARSTRING_template& pat();
const CHARSTRING_template& pat() const;
BOOLEAN_template& res();
const BOOLEAN_template& res() const;
int size_of() const;
void log() const;
void log_match(const cliPattern2match& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class cliPatternlist : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
cliPattern2match **value_elements;
} *val_ptr;

static const cliPattern2match UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const cliPatternlist& other_value);

public:
  typedef cliPattern2match of_type;
cliPatternlist();
cliPatternlist(null_type other_value);
cliPatternlist(const cliPatternlist& other_value);
~cliPatternlist();

void clean_up();
cliPatternlist& operator=(null_type other_value);
cliPatternlist& operator=(const cliPatternlist& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const cliPatternlist& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const cliPatternlist& other_value) const { return !(*this == other_value); }

cliPattern2match& operator[](int index_value);
cliPattern2match& operator[](const INTEGER& index_value);
const cliPattern2match& operator[](int index_value) const;
const cliPattern2match& operator[](const INTEGER& index_value) const;

cliPatternlist operator<<=(int rotate_count) const;
cliPatternlist operator<<=(const INTEGER& rotate_count) const;
cliPatternlist operator>>=(int rotate_count) const;
cliPatternlist operator>>=(const INTEGER& rotate_count) const;

cliPatternlist operator+(const cliPatternlist& other_value) const;

cliPatternlist substr(int index, int returncount) const;

cliPatternlist replace(int index, int len, const cliPatternlist& repl) const;

cliPatternlist replace(int index, int len, const cliPatternlist_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class cliPatternlist_template : public Record_Of_Template {
union {
struct {
int n_elements;
cliPattern2match_template **value_elements;
} single_value;
struct {
unsigned int n_values;
cliPatternlist_template *list_value;
} value_list;
};
void copy_value(const cliPatternlist& other_value);
void copy_template(const cliPatternlist_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
cliPatternlist_template();
cliPatternlist_template(template_sel other_value);
cliPatternlist_template(null_type other_value);
cliPatternlist_template(const cliPatternlist& other_value);
cliPatternlist_template(const OPTIONAL<cliPatternlist>& other_value);
cliPatternlist_template(const cliPatternlist_template& other_value);
~cliPatternlist_template();

void clean_up();
cliPatternlist_template& operator=(template_sel other_value);
cliPatternlist_template& operator=(null_type other_value);
cliPatternlist_template& operator=(const cliPatternlist& other_value);
cliPatternlist_template& operator=(const OPTIONAL<cliPatternlist>& other_value);
cliPatternlist_template& operator=(const cliPatternlist_template& other_value);

cliPattern2match_template& operator[](int index_value);
cliPattern2match_template& operator[](const INTEGER& index_value);
const cliPattern2match_template& operator[](int index_value) const;
const cliPattern2match_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const cliPatternlist& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
cliPatternlist valueof() const;
cliPatternlist substr(int index, int returncount) const;

cliPatternlist replace(int index, int len, const cliPatternlist_template& repl) const;

cliPatternlist replace(int index, int len, const cliPatternlist& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
cliPatternlist_template& list_item(unsigned int list_index);
void log() const;
void log_match(const cliPatternlist& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class CommandStep {
  CHARSTRING field_cmd;
  cliPatternlist field_PatternList;
public:
  CommandStep();
  CommandStep(const CHARSTRING& par_cmd,
    const cliPatternlist& par_PatternList);
  CommandStep(const CommandStep& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CommandStep& operator=(const CommandStep& other_value);
  boolean operator==(const CommandStep& other_value) const;
  inline boolean operator!=(const CommandStep& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& cmd()
    {return field_cmd;}
  inline const CHARSTRING& cmd() const
    {return field_cmd;}
  inline cliPatternlist& PatternList()
    {return field_PatternList;}
  inline const cliPatternlist& PatternList() const
    {return field_PatternList;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class CommandStep_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CommandStep_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CommandStep& other_value);
void copy_template(const CommandStep_template& other_value);

public:
CommandStep_template();
CommandStep_template(template_sel other_value);
CommandStep_template(const CommandStep& other_value);
CommandStep_template(const OPTIONAL<CommandStep>& other_value);
CommandStep_template(const CommandStep_template& other_value);
~CommandStep_template();
CommandStep_template& operator=(template_sel other_value);
CommandStep_template& operator=(const CommandStep& other_value);
CommandStep_template& operator=(const OPTIONAL<CommandStep>& other_value);
CommandStep_template& operator=(const CommandStep_template& other_value);
boolean match(const CommandStep& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CommandStep valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CommandStep_template& list_item(unsigned int list_index) const;
CHARSTRING_template& cmd();
const CHARSTRING_template& cmd() const;
cliPatternlist_template& PatternList();
const cliPatternlist_template& PatternList() const;
int size_of() const;
void log() const;
void log_match(const CommandStep& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CommandList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
CommandStep **value_elements;
} *val_ptr;

static const CommandStep UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const CommandList& other_value);

public:
  typedef CommandStep of_type;
CommandList();
CommandList(null_type other_value);
CommandList(const CommandList& other_value);
~CommandList();

void clean_up();
CommandList& operator=(null_type other_value);
CommandList& operator=(const CommandList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const CommandList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const CommandList& other_value) const { return !(*this == other_value); }

CommandStep& operator[](int index_value);
CommandStep& operator[](const INTEGER& index_value);
const CommandStep& operator[](int index_value) const;
const CommandStep& operator[](const INTEGER& index_value) const;

CommandList operator<<=(int rotate_count) const;
CommandList operator<<=(const INTEGER& rotate_count) const;
CommandList operator>>=(int rotate_count) const;
CommandList operator>>=(const INTEGER& rotate_count) const;

CommandList operator+(const CommandList& other_value) const;

CommandList substr(int index, int returncount) const;

CommandList replace(int index, int len, const CommandList& repl) const;

CommandList replace(int index, int len, const CommandList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class CommandList_template : public Record_Of_Template {
union {
struct {
int n_elements;
CommandStep_template **value_elements;
} single_value;
struct {
unsigned int n_values;
CommandList_template *list_value;
} value_list;
};
void copy_value(const CommandList& other_value);
void copy_template(const CommandList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
CommandList_template();
CommandList_template(template_sel other_value);
CommandList_template(null_type other_value);
CommandList_template(const CommandList& other_value);
CommandList_template(const OPTIONAL<CommandList>& other_value);
CommandList_template(const CommandList_template& other_value);
~CommandList_template();

void clean_up();
CommandList_template& operator=(template_sel other_value);
CommandList_template& operator=(null_type other_value);
CommandList_template& operator=(const CommandList& other_value);
CommandList_template& operator=(const OPTIONAL<CommandList>& other_value);
CommandList_template& operator=(const CommandList_template& other_value);

CommandStep_template& operator[](int index_value);
CommandStep_template& operator[](const INTEGER& index_value);
const CommandStep_template& operator[](int index_value) const;
const CommandStep_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const CommandList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
CommandList valueof() const;
CommandList substr(int index, int returncount) const;

CommandList replace(int index, int len, const CommandList_template& repl) const;

CommandList replace(int index, int len, const CommandList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
CommandList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const CommandList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class SSH__CT__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
COMPONENT **value_elements;
} *val_ptr;

static const COMPONENT UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SSH__CT__list& other_value);

public:
  typedef COMPONENT of_type;
SSH__CT__list();
SSH__CT__list(null_type other_value);
SSH__CT__list(const SSH__CT__list& other_value);
~SSH__CT__list();

void clean_up();
SSH__CT__list& operator=(null_type other_value);
SSH__CT__list& operator=(const SSH__CT__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SSH__CT__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SSH__CT__list& other_value) const { return !(*this == other_value); }

COMPONENT& operator[](int index_value);
COMPONENT& operator[](const INTEGER& index_value);
const COMPONENT& operator[](int index_value) const;
const COMPONENT& operator[](const INTEGER& index_value) const;

SSH__CT__list operator<<=(int rotate_count) const;
SSH__CT__list operator<<=(const INTEGER& rotate_count) const;
SSH__CT__list operator>>=(int rotate_count) const;
SSH__CT__list operator>>=(const INTEGER& rotate_count) const;

SSH__CT__list operator+(const SSH__CT__list& other_value) const;

SSH__CT__list substr(int index, int returncount) const;

SSH__CT__list replace(int index, int len, const SSH__CT__list& repl) const;

SSH__CT__list replace(int index, int len, const SSH__CT__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SSH__CT__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
COMPONENT_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SSH__CT__list_template *list_value;
} value_list;
};
void copy_value(const SSH__CT__list& other_value);
void copy_template(const SSH__CT__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SSH__CT__list_template();
SSH__CT__list_template(template_sel other_value);
SSH__CT__list_template(null_type other_value);
SSH__CT__list_template(const SSH__CT__list& other_value);
SSH__CT__list_template(const OPTIONAL<SSH__CT__list>& other_value);
SSH__CT__list_template(const SSH__CT__list_template& other_value);
~SSH__CT__list_template();

void clean_up();
SSH__CT__list_template& operator=(template_sel other_value);
SSH__CT__list_template& operator=(null_type other_value);
SSH__CT__list_template& operator=(const SSH__CT__list& other_value);
SSH__CT__list_template& operator=(const OPTIONAL<SSH__CT__list>& other_value);
SSH__CT__list_template& operator=(const SSH__CT__list_template& other_value);

COMPONENT_template& operator[](int index_value);
COMPONENT_template& operator[](const INTEGER& index_value);
const COMPONENT_template& operator[](int index_value) const;
const COMPONENT_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SSH__CT__list& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SSH__CT__list valueof() const;
SSH__CT__list substr(int index, int returncount) const;

SSH__CT__list replace(int index, int len, const SSH__CT__list_template& repl) const;

SSH__CT__list replace(int index, int len, const SSH__CT__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SSH__CT__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SSH__CT__list& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};


/* Function prototypes */

extern SSHCLIENTasp__Types::ASP__SSH__SetUserID_template t__ASP__SSH__SetUserID(const CHARSTRING& ui);
extern SSHCLIENTasp__Types::ASP__SSH__SetPrompt_template t__ASP__SSH__SetPrompt(const CHARSTRING& sp);
extern SSHCLIENTasp__Types::ASP__SSH__SetRegexPrompt_template t__ASP__SSH__SetRegexPrompt(const CHARSTRING& sp);
extern SSHCLIENTasp__Types::ASP__SSH__SetRemoteHost_template t__ASP__SSH__SetRemoteHost(const CHARSTRING& rh);
extern SSHCLIENTasp__Types::ASP__SSH__SetRemotePort_template t__ASP__SSH__SetRemotePort(const CHARSTRING& rp);
extern SSHCLIENTasp__Types::ASP__SSH__SetAdditionalParameters_template t__ASP__SSH__SetAdditionalParameters(const CHARSTRING& ap);
extern SSHCLIENTasp__Types::ASP__SSH__SetMode_template t__ASP__SSH__SetMode(const INTEGER& readmode);
extern boolean operator==(null_type null_value, const cliPatternlist& other_value);
inline boolean operator!=(null_type null_value, const cliPatternlist& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const CommandList& other_value);
inline boolean operator!=(null_type null_value, const CommandList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const SSH__CT__list& other_value);
inline boolean operator!=(null_type null_value, const SSH__CT__list& other_value) { return !(null_value == other_value); }
extern alt_status as__conversation__error_instance();
extern void as__conversation__error();
extern Default_Base *activate_as__conversation__error();
extern alt_status as__T__SSHresp__timeout_instance();
extern void as__T__SSHresp__timeout();
extern Default_Base *activate_as__T__SSHresp__timeout();
extern alt_status as__prompt_instance();
extern void as__prompt();
extern Default_Base *activate_as__prompt();
extern alt_status as__status_instance();
extern void as__status();
extern Default_Base *activate_as__status();
extern BOOLEAN f__sshCLIconversation(const CommandList& clist, const FLOAT& cliTimeOut);
extern void start_f__sshCLIconversation(const COMPONENT& component_reference, const CommandList& clist, const FLOAT& cliTimeOut);
extern BOOLEAN f__sshLogin(const CHARSTRING& username, const CHARSTRING& passwd);
extern void start_f__sshLogin(const COMPONENT& component_reference, const CHARSTRING& username, const CHARSTRING& passwd);
extern void f__sshLogout(const BOOLEAN& unmapSSH);
extern void start_f__sshLogout(const COMPONENT& component_reference, const BOOLEAN& unmapSSH);
extern BOOLEAN f__sshChmod(const CHARSTRING& chmod__options, const CHARSTRING& files2chmod);
extern void start_f__sshChmod(const COMPONENT& component_reference, const CHARSTRING& chmod__options, const CHARSTRING& files2chmod);
extern BOOLEAN f__sshCd(const CHARSTRING& dirname);
extern void start_f__sshCd(const COMPONENT& component_reference, const CHARSTRING& dirname);
extern BOOLEAN f__sshCp(const CHARSTRING& scrfile, const CHARSTRING& destfile);
extern void start_f__sshCp(const COMPONENT& component_reference, const CHARSTRING& scrfile, const CHARSTRING& destfile);
extern BOOLEAN f__sshMv(const CHARSTRING& mv__src, const CHARSTRING& mv__dest);
extern void start_f__sshMv(const COMPONENT& component_reference, const CHARSTRING& mv__src, const CHARSTRING& mv__dest);
extern BOOLEAN f__sshFileExists(const CHARSTRING& myfile);
extern void start_f__sshFileExists(const COMPONENT& component_reference, const CHARSTRING& myfile);
extern CHARSTRING f__sshLs(const CHARSTRING& lsparam);
extern void start_f__sshLs(const COMPONENT& component_reference, const CHARSTRING& lsparam);
extern CHARSTRING f__sshRm(const CHARSTRING& rmparam);
extern void start_f__sshRm(const COMPONENT& component_reference, const CHARSTRING& rmparam);
extern BOOLEAN f__sshSsh(const CHARSTRING& ipaddr, const CHARSTRING& passwd);
extern void start_f__sshSsh(const COMPONENT& component_reference, const CHARSTRING& ipaddr, const CHARSTRING& passwd);
extern BOOLEAN f__sshExit();
extern void start_f__sshExit(const COMPONENT& component_reference);

/* Global variable declarations */

extern const FLOAT& sshDefaultRespTimeout;
extern const FLOAT& login__waittime;
extern const SSHCLIENTasp__Types::ASP__SSH__ClearPrompt_template& t__ASP__SSH__ClearPrompt;
extern const SSHCLIENTasp__Types::ASP__SSH__Connect_template& t__ASP__SSH__Connect;
extern const SSHCLIENTasp__Types::ASP__SSH__Close_template& t__ASP__SSH__Close;
extern const SSHCLIENTasp__Types::ASP__SSH__PseudoPrompt_template& t__ASP__SSH__PseudoPrompt;
extern const SSHCLIENTasp__Types::ASP__SSH__Status_template& t__ASP__SSH__Status;
extern const SSHCLIENTasp__Types::ASP__SSH__Status_template& t__ASP__SSH__Status__OK;
extern const CHARSTRING_template& t__ASP__SSH;
extern const XERdescriptor_t cliPattern2match_pat_xer_;
extern const TTCN_JSONdescriptor_t cliPattern2match_pat_json_;
extern const TTCN_Typedescriptor_t cliPattern2match_pat_descr_;
extern const XERdescriptor_t cliPattern2match_res_xer_;
extern const TTCN_JSONdescriptor_t cliPattern2match_res_json_;
extern const TTCN_OERdescriptor_t cliPattern2match_res_oer_;
extern const TTCN_Typedescriptor_t cliPattern2match_res_descr_;
extern const TTCN_Typedescriptor_t cliPattern2match_descr_;
extern const TTCN_Typedescriptor_t cliPatternlist_descr_;
extern const XERdescriptor_t CommandStep_cmd_xer_;
extern const TTCN_JSONdescriptor_t CommandStep_cmd_json_;
extern const TTCN_Typedescriptor_t CommandStep_cmd_descr_;
extern const TTCN_Typedescriptor_t CommandStep_descr_;
extern const TTCN_Typedescriptor_t CommandList_descr_;
extern const TTCN_Typedescriptor_t& SSH__CT_descr_;
extern SSHCLIENTasp__PortType::SSHCLIENTasp__PT SSH__CT_component_SSH__PCO;
extern TIMER SSH__CT_component_T__sshResp;
extern CHARSTRING SSH__CT_component_sshRespStr;
extern const TTCN_Typedescriptor_t SSH__CT__list_descr_;
extern const TTCN_Typedescriptor_t& MTC__CT_descr_;
extern SSH__CT__list MTC__CT_component_cliClient;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
